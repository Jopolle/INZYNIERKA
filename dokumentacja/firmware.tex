\chapter{Firmware}
Część programowa projektu pełni rolę interfejsu pomiędzy opracowaną platformą sprzętową a docelowym użytkownikiem – studentem realizującym ćwiczenia. Jej zadaniem jest nie tylko poprawne sterowanie wyjściami analogowymi i akwizycja sygnałów 0--10~V z przetworników, ale również prezentacja stanu układu w czytelnej formie graficznej, umożliwienie zmiany parametrów regulatora oraz wygodne przełączanie konfiguracji laboratoryjnych bez konieczności rekompilacji oprogramowania.

Z tego powodu firmware nie został zbudowany jako prosta aplikacja ,,bare--metal'' ani w oparciu o szablony generatora STM32CubeMX, lecz jako aplikacja systemu Zephyr RTOS, z wykorzystaniem biblioteki \texttt{LVGL} do budowy interfejsu użytkownika. W kolejnych podrozdziałach opisano motywację tego wyboru, strukturę aplikacji, opis modelu konfiguracji systemu HVAC w oparciu o JSON, logikę regulacji oraz działanie interfejsu HMI.


\section{Wybór środowiska uruchomieniowego}

Projekt wymaga równoległego i deterministycznego wykonywania kilku zadań: odświeżania HMI na wyświetlaczu TFT, generacji sygnałów \mbox{0--10~V} (komunikacja SPI z przetwornicą DAC) oraz obsługa drugiej magistrali SPI do komunikacji z przetwornicą ADC. Wszystkie te funkcje muszą być realizowane przy zachowaniu powtarzalnych czasów reakcji. Z tych powodów jako środowisko uruchomieniowe wybrano \texttt{Zephyr RTOS} zintegrowany z biblioteką graficzną \texttt{LVGL}.

Zastosowanie systemu czasu rzeczywistego zamiast prostego ,,bare--metal'' pozwala w prosty sposób rozdzielić zadania i przypisać je do osobnych wątków: wątku interfejsu użytkownika, wątków akwizycji i przetwarzania danych oraz wątków odpowiedzialnych za komunikację ze sprzętem. Dzięki temu możliwe jest jednoczesne utrzymanie płynnego odświeżania UI, bezpiecznej obsługi przerwań z przetworników oraz terminowego odświeżania wyjść analogowych sterujących urządzeniami HVAC.

\subsection{Dlaczego Zephyr + LVGL?}

Zephyr udostępnia deterministyczny kernel o prostym, ale wystarczająco elastycznym modelu współbieżności. Wątki o priorytetach, kolejki \emph{workqueue}, przerwania oraz timery wysokiej rozdzielczości umożliwiają zdefiniowanie jasnego podziału zadań i ich wzajemnych zależności. W projekcie wykorzystano tę możliwość do wydzielenia ścieżki krytycznej czasowo (akwizycja i generacja sygnałów) od zadań mniej wrażliwych na opóźnienia (obsługa UI, diagnostyka, ładowanie konfiguracji). Tryb \emph{tickless} ogranicza narzut związany z tykaniem systemowym, a jednocześnie pozwala zachować stałe okresy odświeżania UI oraz stabilne czasy próbkowania.

Istotną zaletą Zephyra jest spójny ekosystem sterowników oraz wspólna warstwa konfiguracji sprzętu. Standardowe API dla interfejsów SPI, I\textsuperscript{2}C, ADC, DAC/PWM, GPIO czy DMA, uzupełnione mechanizmami \texttt{DeviceTree} i \texttt{Kconfig}, redukuje do minimum ilość kodu,,klejącego'' między aplikacją a warstwą sprzętową. Dla mikrokontrolerów z rodziny STM32 dostępne są gotowe drivery oraz integracja z biblioteką HAL producenta, co znacząco przyspiesza uruchomienie peryferiów, takich jak kontroler SPI współpracujący z zewnętrznymi przetwornikami A/C i C/A. Zmiana konfiguracji sprzętu (np.\ inny pin \mbox{CS}, dodatkowy kanał) sprowadza się najczęściej do modyfikacji pliku \texttt{.overlay} \texttt{DeviceTree}, bez ingerencji w logikę aplikacyjną.

Zephyr dostarcza ponadto oficjalny subsystem \texttt{LVGL}, odpowiedzialny za integrację biblioteki graficznej z systemem operacyjnym. W praktyce oznacza to gotową obsługę zegara \emph{tick}, wątku renderującego, przydziału pamięci oraz sterowników wyświetlaczy i urządzeń wejściowych. Konfiguracja odbywa się poprzez parę \texttt{Kconfig}+\texttt{DeviceTree}, gdzie określa się m.in.\ rozmiary buforów ekranu, sposób odświeżania (\emph{flush callback}) oraz mapowanie wejścia dotykowego. Dzięki temu warstwa HMI może zostać zaimplementowana w całości w LVGL, bez konieczności ręcznego "sklejania” sterownika wyświetlacza, sterownika dotyku i logiki zadań systemowych.

Wybór Zephyra jest również uzasadniony dostępnością narzędzi deweloperskich oraz ekosystemu okołosystemowego. Jednolity system budowania oparty na \texttt{CMake} i menedżerze \texttt{west}, wbudowany logger, konsola \texttt{shell}, obsługa trwałych ustawień (NVS), różne systemy plików (FAT, LittleFS) oraz zintegrowany framework testowy (\texttt{twister}) ułatwiają utrzymanie projektu oraz jego automatyzację. W kontekście pracy inżynierskiej ważna jest także skalowalność: Zephyr oferuje stosy sieciowe (Ethernet, BLE, IP), jak również bootloader \texttt{MCUboot}, co otwiera drogę do przyszłego rozszerzenia urządzenia o zdalne aktualizacje czy komunikację sieciową bez zmiany fundamentów projektu.

Biblioteka LVGL, wykorzystana jako warstwa HMI, jest naturalnym wyborem dla mikrokontrolerów klasy STM32F7 z kolorowym TFT. Zapewnia rozbudowany zestaw widżetów (przyciski, suwaki, listy rozwijane, wykresy) oraz mechanizmy układu obiektów (flex, grid), co pozwala zbudować zarówno ekran diagnostyczny, jak i bardziej złożony panel sterowania. LVGL jest aktywnie rozwijana, dobrze udokumentowana i szeroko stosowana w systemach wbudowanych, a jej integracja z Zephyrem jest oficjalnie wspierana. Użycie powszechnie znanego stosu Zephyr+LVGL zmniejsza ryzyko problemów z utrzymaniem projektu w przyszłości.

Nie bez znaczenia pozostaje kwestia licencjonowania i wsparcia społeczności. Zephyr jest projektem rozwijanym pod licencją \texttt{Apache-2.0}, a LVGL pod licencją \texttt{MIT}. Obie licencje są permisywne i sprzyjają wykorzystaniu w projektach komercyjnych oraz akademickich. Aktywne społeczności użytkowników oraz profesjonalne wsparcie firm współtworzących te projekty ułatwiają rozwiązywanie problemów oraz zapewniają długoterminową stabilność stosu programowego.

